#!/usr/bin/env bash

#-------------------------------------------------------------------------------
# ai-b-bios-hc
# Appelé par ai-b
#
# Script d'installation en mode BIOS
# et ne fonctionne qu'avec la langue FR (fr_FR)
#
#-------------------------------------------------------------------------------

    #CREATE PARTITION {{{
    create_partition() {
        zero_the_drive() {
            #
            # Voir : https://wiki.archlinux.org/index.php/Beginners%27_guide#Erase_partition_table
            # sgdisk --zap-all /dev/sda
            local retour=9
            local messages=""
            local fonction="PARTITIONNEMENT : MISE À ZÉRO DU DISQUE «"${HDD_DEVICE}"».\n"
            fonction+="===================================================\n\n"
            messages="${fonction}"
            messages+="/!\ Si Multi Boot, NE PAS METTRE À ZÉRO le disque.\n"
            messages+="/!\ TOUTES les données sur le disque sélectionné seront perdues.\n\n"
            messages+="Confirmer la mise à zéro du disque «"${HDD_DEVICE}"»\n"
            print_whiptail_yesno_no "${messages}" "Mettre à zéro" "Annuler"
            retour=$?
            if [[ $retour = 0 ]]; then
                retour=9
                messages="${fonction}"
                messages+="Confirmer une 2ème fois la mise à zéro du disque «"${HDD_DEVICE}"»\n"
                print_whiptail_yesno_no "${messages}" "Mettre à zéro" "Annuler"
                retour=$?
                if [[ $retour = 0 ]]; then
                    sgdisk --zap-all ${HDD_DEVICE}
                    sync
                fi
            fi
        }
        appel_check_is_hdd_or_ssd() {
            local retour=9
            local messages=""
            local fonction="PARTITIONNEMENT : TYPE DE DISQUE.\n"
            fonction+="=================================\n\n"
            messages="${fonction}"
            check_is_hdd_or_ssd "${HDD_DEVICE}"
            if [[ ${IS_HDD_OR_SSD} == "HDD" ]]; then
                messages+="!!! Le Disque «"${HDD_DEVICE}"» est un HDD.\n"
            else
                messages+="!!! Le Disque «"${HDD_DEVICE}"» est un SSD.\n"
            fi
            print_whiptail_msgbox "${messages}" "Continuer"
        }
        select_storage_partitions() {
            local messages=""
            local fonction="PARTITIONNEMENT : SÉLECTION DU TYPE DE TABLE DE PARTITIONS.\n"
            fonction+="===========================================================\n\n"
            messages="${fonction}"
            messages+="/!\ En mode BIOS (PAS UEFI), si dual boot avec Windows :\n"
            messages+="/!\ NE PAS CHOISIR GPT.\n\n"
            messages+="Sélectionner le type de table de partitions ( MSDOS ou GPT ) :"
            TYPE_STORAGE_PARTITION=$(whiptail --nocancel --title "${TITRE_BOX_W}" --menu "${messages}" --ok-button "Valider" 20 72 5 \
                                    "MSDOS" "-" \
                                    "GPT" "-" \
                                    3>&1 1>&2 2>&3)
            
            messages="${fonction}"
            if [[ $TYPE_STORAGE_PARTITION == "MSDOS" ]]; then
                messages+="«cfdisk» sera lancé afin de créer les partitions sur «"${HDD_DEVICE}"»\n\n"
            else
                messages+="«cgdisk» sera lancé afin de créer les partitions sur «"${HDD_DEVICE}"»\n\n"
                messages+="/!\ Si GRUB est prévu, une partition de 2 Mio de type EF02\n"
                messages+="/!\ doit être créée en 1er sur «"${HDD_DEVICE}"».\n"
            fi
            print_whiptail_msgbox "${messages}" "Continuer"
        }
        select_hdd_devices() {
            local messages=""
            local fonction="PARTITIONNEMENT : SÉLECTION DU DISQUE À PARTITIONNER.\n"
            fonction+="=====================================================\n\n"
            messages="${fonction}"
            local liste_disque_present=$(LC_ALL=C parted -sl 2> /dev/null | grep -E 'Mod|/dev/sd[a-z]' | sed -e "s/\(^Disk.*\)/\1\n/;s/Model/Modèle/;s/Disk/Disque/")
            messages+="Liste des Disques présents dans le PC :\n"
            messages+="---------------------------------------\n"
            messages+=${liste_disque_present}"\n\n"
            messages+="Sélectionner le Disque à partitionner :"
            local hauteur=0
            local nb_hdd=$(LC_ALL=C parted -sl 2> /dev/null | grep "/dev/sd[a-z]" | wc -l)
            if [[ $nb_hdd = 1 || $nb_hdd = 2 ]]; then
                hauteur=25
            elif [[ $nb_hdd = 3 || $nb_hdd = 4 ]]; then
                hauteur=35
            else
                hauteur=40
            fi
            local liste_hdd_devices=$(LC_ALL=C parted -sl 2> /dev/null | grep "/dev/sd[a-z]" | sed -e "s/://" | awk '{print $2   " "   $3$4}')
            HDD_DEVICE=$(whiptail --nocancel --title "${TITRE_BOX_W}" --menu "${messages}" --ok-button "Valider" $hauteur 72 5 ${liste_hdd_devices} 3>&1 1>&2 2>&3)
        }
        #
        select_hdd_devices
        #
        appel_check_is_hdd_or_ssd
        #
        zero_the_drive
        #
        select_storage_partitions
        if [[ $TYPE_STORAGE_PARTITION == "MSDOS" ]]; then
            cfdisk $HDD_DEVICE
        else
            cgdisk $HDD_DEVICE
        fi
    }
    #}}}
    #FORMAT DEVICE {{{
    format_device() {
        print_title "https://wiki.archlinux.org/index.php/Format_a_device"
        print_info "Cette étape permet de sélectionner et formater les partitions sélectionnées où Archlinux sera installé."
        print_warning "\tToutes les données sur les partitions sélectionnées seront perdues."
        i=0
        partitions=($(fdisk -l $HDD_DEVICE | awk '{print $1}' | grep /dev/))
# SI EN GPT : 1ère partition  = EF02 BIOS_BOOT_PARTITION ou BOOT_PAR_NUM
        if [[ $TYPE_STORAGE_PARTITION == "GPT" ]]; then
            print_info_cyan "En GPT : la 1ère partition est réservée ( BIOS_BOOT_PARTITION ou BOOT_PAR_NUM )"
            unset partitions[0]
            partitions=(${partitions[@]})
        fi
        device_name=("root" "swap" "home" "boot" "var" "autre")
        select_filesystem() {
            MY_DIR=${device_name[i]}
            [[ -n $1 ]] && MY_DIR=$1
            filesystem=("ext4" "reiserfs" "ntfs" "vfat" "ext2" "ext3" "jfs" "xfs");
            PS3="$prompt1"
            echo -e "Sélectionner le système de fichiers pour ${BYellow}${MY_DIR}${White} :\n"
            select TYPE in "${filesystem[@]}"; do
                if contains_element "$TYPE" "${filesystem[@]}"; then
                    break
                else
                    invalid_option
                fi
            done
        }
        umount_partition() {
            #check if swap is on and umount
            swapon -s | grep $1 && swapoff $1
            #check if partition is mounted and umount
            mount | grep $1 && umount $1
        }
        remove_partition() {
            #remove the selected partition from list
            unset partitions[$DEVICE_NUMBER]
            partitions=(${partitions[@]})
            #increase i
            [[ ${device_name[i]} != autre ]] && i=$(( i + 1 ))
        }
        format_partition() {
            echo -e "\n${BWhite}Formatage de la partition $1...${White}"
#            echo -e "\n"
#            read_input_text "Confirmer le formatage de la partition $1"
#            if [[ $OPTION == o ]]; then
                umount_partition "$1"
                [[ -z $3 ]] && select_filesystem
                if [[ $1 == $ROOT ]]; then
                    ROOT_FS_TYPE=$TYPE
                fi
                mkfs.$TYPE $1
                fsck $1
                tune2fs -c 30 $1
                mkdir -p $2
                mount -t $TYPE $1 $2
                remove_partition "$1"
#            fi
        }
        format_swap_partition() {
            echo -e "\n${BWhite}Formatage de la partition $1...${White}"
            echo -e "\n${BWhite}Si Multi Boot, NE PAS FORMATER la partition SWAP.${White}"
            read_input_text "Confirmer le formatage de la partition $1"
            if [[ $OPTION == o ]]; then
                umount_partition "$1"
                mkswap $1
                swapon $1
                remove_partition "$1"
            else
                umount_partition "$1"
                swapon $1
                remove_partition "$1"
            fi
        }
        check_mountpoint() {
            if mount | grep $2; then
                echo -e "${BWhite}Partition montée avec succès${White}"
                remove_partition "$1"
            else
                echo -e "${BRed}ATTENTION: Partition NON montée${White}"
            fi
        }
        while true; do
            print_warning "\tToutes les données sur la partition sélectionnée seront perdues."
            if [[ ${device_name[i]} != root ]]; then
                echo -e "${BWhite}Sélection optionnelle d'une partition pour : ${White}${BYellow}${device_name[i]}${White}"
                read_input_text "Sélectionner une partition pour ${device_name[i]}"
                if [[ $OPTION == n ]]; then
                    if [[ ${device_name[i]} == autre ]]; then
                        break
                    else
                        i=$(( i + 1 ))
                        continue
                    fi
                fi
            fi
            [[ -n ${CHOIX_PARTITIONS} ]] && echo -e "${BWhite}==> ${CHOIX_PARTITIONS}${White}\n"
            PS3="$prompt1"
            echo -e "Sélectionner une partition pour ${BYellow}${device_name[i]}${White} :\n"
            select DEVICE in "${partitions[@]}" "Fini"; do
                if [[ "$DEVICE" == "Fini" ]]; then
                    QUIT_FORMAT=$DEVICE
                    break
                else
                  #get the selected number - 1
                  DEVICE_NUMBER=$(( $REPLY - 1 ))
                  if contains_element "$DEVICE" "${partitions[@]}"; then
                      case ${device_name[i]} in
                          root)
                              ROOT=$DEVICE
                              ROOT_DEVICE=$(echo $ROOT | sed 's/[0-9]//')
                              format_partition "$DEVICE" "${MOUNTPOINT}"
                              CHOIX_PARTITIONS+=$(echo $DEVICE)" = /root  "
                              echo
                              ;;
                          swap)
                              format_swap_partition "$DEVICE"
                              CHOIX_PARTITIONS+=$(echo $DEVICE)" = /swap\n==> "
                              echo
                              ;;
                          home)
                              DIR="/home"
                              select_filesystem "${DIR}"
                              format_partition "$DEVICE" "${MOUNTPOINT}${DIR}" "$TYPE"
                              CHOIX_PARTITIONS+=$(echo $DEVICE)" = /home  "
                              echo
                              ;;
                          boot)
                              DIR="/boot"
                              select_filesystem "${DIR}"
                              format_partition "$DEVICE" "${MOUNTPOINT}${DIR}" "$TYPE"
                              CHOIX_PARTITIONS+=$(echo $DEVICE)" = /boot  "
                              echo
                              ;;
                          var)
                              DIR="/var"
                              select_filesystem "${DIR}"
                              format_partition "$DEVICE" "${MOUNTPOINT}${DIR}" "$TYPE"
                              IS_VAR_SEPARATE=1
                              CHOIX_PARTITIONS+=$(echo $DEVICE)" = /var  "
                              echo
                              ;;
                          autre)
                              read -p "Point de montage pour $DEVICE ( ex: /Datas, ... ) : " DIR
                              select_filesystem "${DIR}"
                              echo ""
                              read_input_text "Formater la partition $DEVICE"
                              if [[ $OPTION != n ]]; then
                                  format_partition "$DEVICE" "${MOUNTPOINT}${DIR}" "$TYPE"
                              else
                                  read_input_text "Confirmer : type="$TYPE" device="$DEVICE" dir="${DIR}""
                                  if [[ $OPTION != n ]]; then
                                      mkdir -p ${MOUNTPOINT}${DIR}
                                      mount -t $TYPE $DEVICE ${MOUNTPOINT}${DIR}
                                      check_mountpoint "$DEVICE" "${MOUNTPOINT}${DIR}"
                                  fi
                              fi
                              CHOIX_PARTITIONS+=$(echo $DEVICE)" = "$(echo $DIR)"  "
                              echo
                              ;;
                      esac
                      break
                  else
                      invalid_option
                  fi
                fi
            done
            #check if there is no partitions left
            if [[ ${QUIT_FORMAT} == "Fini" ]]; then
                break
            elif [[ ${#partitions[@]} -eq 0 ]]; then
                break
            elif [[ ${device_name[i]} == autre ]]; then
                echo
                read_input_text "Configurer une autre partition"
                [[ $OPTION != o ]] && break
            fi
        done
    }
    #}}}
